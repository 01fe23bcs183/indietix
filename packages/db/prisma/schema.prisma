generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  CUSTOMER
  ORGANIZER
  ADMIN
}

enum Category {
  MUSIC
  COMEDY
  SPORTS
  TECH
  FOOD
  ART
  OTHER
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  SOLD_OUT
  COMPLETED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  ATTENDED
}

enum RefundStatus {
  PENDING
  APPROVED
  PROCESSING
  SUCCEEDED
  FAILED
  REJECTED
}

enum WaitlistStatus {
  ACTIVE
  INVITED
  CLAIMED
  EXPIRED
}

enum WaitlistOfferStatus {
  PENDING
  CLAIMED
  EXPIRED
  CANCELLED
}

enum PayoutStatus {
  PENDING
  APPROVED
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String
  name          String
  phone         String?
  role          Role      @default(CUSTOMER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  sessions      Session[]
  organizer     Organizer?
  bookings      Booking[]

  @@index([email])
  @@index([role])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
}

model Organizer {
  id           String   @id @default(cuid())
  userId       String   @unique
  businessName String
  description  String?
  verified     Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  events       Event[]
  payouts      Payout[]

  @@index([userId])
  @@index([verified])
}

model Event {
  id                        String      @id @default(cuid())
  organizerId               String
  title                     String
  slug                      String      @unique
  description               String
  category                  Category
  city                      String
  venue                     String
  date                      DateTime
  price                     Int
  totalSeats                Int
  bookedSeats               Int         @default(0)
  status                    EventStatus @default(DRAFT)
  allowCancellation         Boolean     @default(true)
  cancellationDeadlineHours Int         @default(24)
  cancellationFeeFlat       Int         @default(50)
  createdAt                 DateTime    @default(now())
  updatedAt                 DateTime    @updatedAt
  
  organizer                 Organizer        @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  bookings                  Booking[]
  waitlistEntries           WaitlistEntry[]
  views                     EventView[]

  @@index([slug])
  @@index([organizerId])
  @@index([city])
  @@index([category])
  @@index([date])
  @@index([status])
}

model EventView {
  id        String   @id @default(cuid())
  eventId   String
  userId    String?
  createdAt DateTime @default(now())
  
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId, createdAt])
}

model Booking {
  id                 String        @id @default(cuid())
  eventId            String
  userId             String
  ticketNumber       String        @unique
  seats              Int
  ticketPrice        Int
  convenienceFee     Int
  platformFee        Int
  finalAmount        Int
  paymentStatus      PaymentStatus @default(PENDING)
  status             BookingStatus @default(PENDING)
  razorpayOrderId    String?
  razorpayPaymentId  String?
  holdExpiresAt      DateTime
  cancelledAt        DateTime?
  attendedAt         DateTime?
  qrCode             String?
  ticketPayloadHash  String?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  
  event              Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user               User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  paymentEvents      PaymentEvent[]
  scanLogs           ScanLog[]
  refunds            Refund[]

  @@index([eventId])
  @@index([userId])
  @@index([paymentStatus])
  @@index([status])
  @@index([holdExpiresAt])
  @@index([ticketNumber])
}

model Payout {
  id                String       @id @default(cuid())
  organizerId       String
  
  periodStart       DateTime
  periodEnd         DateTime
  
  amount            Int          // in paise
  currency          String       @default("INR")
  
  status            PayoutStatus @default(PENDING)
  
  // Audit fields
  beneficiaryName   String
  accountMasked     String?
  breakdown         Json         // { gmv, refunds, fees, netPayable, eventCount, bookingCount }
  
  // Provider fields
  provider          String?      // "FAKE" | "RAZORPAYX"
  providerPayoutId  String?
  providerResponse  Json?
  
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  approvedAt        DateTime?
  approvedBy        String?
  processedAt       DateTime?
  completedAt       DateTime?
  
  organizer         Organizer    @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  paymentEvents     PaymentEvent[]

  @@index([organizerId])
  @@index([status])
  @@index([periodStart, periodEnd])
}

model PaymentEvent {
  id                 String   @id @default(cuid())
  provider           String
  eventId            String   @unique
  providerEventType  String?
  bookingId          String?
  refundId           String?
  payoutId           String?
  payload            Json
  createdAt          DateTime @default(now())
  
  booking            Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  refund             Refund?  @relation(fields: [refundId], references: [id], onDelete: Cascade)
  payout             Payout?  @relation(fields: [payoutId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@index([refundId])
  @@index([payoutId])
  @@index([eventId])
}

model ScanLog {
  id          String   @id @default(cuid())
  bookingId   String
  organizerId String
  status      String
  reason      String?
  deviceInfo  String?
  createdAt   DateTime @default(now())
  
  booking     Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId, createdAt])
  @@index([organizerId])
}

model Refund {
  id                String       @id @default(cuid())
  bookingId         String
  amount            Int
  currency          String       @default("INR")
  status            RefundStatus @default(PENDING)
  reason            String?
  provider          String
  providerRefundId  String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  processedAt       DateTime?
  failedAt          DateTime?
  failureReason     String?
  
  booking           Booking      @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  paymentEvents     PaymentEvent[]

  @@index([bookingId])
  @@index([status])
  @@index([createdAt])
}

model WaitlistEntry {
  id         String         @id @default(cuid())
  eventId    String
  userId     String?
  email      String
  phone      String?
  status     WaitlistStatus @default(ACTIVE)
  createdAt  DateTime       @default(now())
  invitedAt  DateTime?
  claimedAt  DateTime?
  expiredAt  DateTime?
  
  event      Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  offers     WaitlistOffer[]

  @@index([eventId, status])
  @@index([email])
  @@index([createdAt])
}

model WaitlistOffer {
  id         String              @id @default(cuid())
  eventId    String
  entryId    String
  quantity   Int                 @default(1)
  expiresAt  DateTime
  status     WaitlistOfferStatus @default(PENDING)
  createdAt  DateTime            @default(now())
  claimedAt  DateTime?
  expiredAt  DateTime?
  
  entry      WaitlistEntry       @relation(fields: [entryId], references: [id], onDelete: Cascade)

  @@index([entryId])
  @@index([status])
  @@index([expiresAt])
  @@index([createdAt])
}
